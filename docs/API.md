# ðŸ“š Polymarket Bot API Reference

Complete API documentation for the Polymarket Trading Bot library.

## Table of Contents

1. [Core Types](#core-types)
2. [Client Module](#client-module)
3. [Model Module](#model-module)
4. [Strategy Module](#strategy-module)
5. [Executor Module](#executor-module)
6. [Ingester Module](#ingester-module)
7. [Storage Module](#storage-module)
8. [Notify Module](#notify-module)
9. [Monitor Module](#monitor-module)

---

## Core Types

### `types.rs`

#### `Market`

Represents a prediction market.

```rust
pub struct Market {
    pub id: String,
    pub question: String,
    pub description: Option<String>,
    pub end_date: Option<DateTime<Utc>>,
    pub volume: Decimal,
    pub liquidity: Decimal,
    pub outcomes: Vec<Outcome>,
    pub active: bool,
    pub closed: bool,
}

impl Market {
    /// Get the Yes outcome price (0.0 - 1.0)
    pub fn yes_price(&self) -> Option<Decimal>;
    
    /// Get the No outcome price (0.0 - 1.0)
    pub fn no_price(&self) -> Option<Decimal>;
    
    /// Check for arbitrage opportunity (Yes + No < 1)
    pub fn arbitrage_opportunity(&self) -> Option<Decimal>;
}
```

**Example:**
```rust
let market = gamma.get_market("0x123...").await?;
println!("Question: {}", market.question);
println!("Yes price: {:.2}%", market.yes_price().unwrap() * 100);
```

#### `Signal`

A trading signal generated by the strategy.

```rust
pub struct Signal {
    pub market_id: String,
    pub token_id: String,
    pub side: Side,
    pub model_probability: Decimal,
    pub market_probability: Decimal,
    pub edge: Decimal,
    pub confidence: Decimal,
    pub suggested_size: Decimal,  // As fraction of portfolio
    pub timestamp: DateTime<Utc>,
}

impl Signal {
    /// Check if signal meets trading thresholds
    pub fn is_tradeable(&self, min_edge: Decimal, min_confidence: Decimal) -> bool;
}
```

#### `Trade`

Record of an executed trade.

```rust
pub struct Trade {
    pub id: String,
    pub order_id: String,
    pub token_id: String,
    pub market_id: String,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub fee: Decimal,
    pub timestamp: DateTime<Utc>,
}
```

#### `Order`

An order to be placed.

```rust
pub struct Order {
    pub token_id: String,
    pub side: Side,           // Buy or Sell
    pub price: Decimal,       // 0.01 - 0.99
    pub size: Decimal,        // Number of shares
    pub order_type: OrderType, // GTC, FOK, GTD
}
```

#### `Side` / `OrderType`

```rust
pub enum Side {
    Buy,
    Sell,
}

pub enum OrderType {
    GTC,  // Good Till Cancelled
    FOK,  // Fill Or Kill
    GTD,  // Good Till Date
}
```

---

## Client Module

### `client/mod.rs`

#### `PolymarketClient`

Unified client for all Polymarket APIs.

```rust
pub struct PolymarketClient {
    pub clob: ClobClient,   // Trading API
    pub gamma: GammaClient, // Market data API
}

impl PolymarketClient {
    /// Create new client from configuration
    pub async fn new(config: PolymarketConfig) -> Result<Self>;
    
    /// Create WebSocket stream for real-time data
    pub async fn market_stream(&self, token_ids: Vec<String>) -> Result<MarketStream>;
}
```

**Example:**
```rust
use polymarket_bot::client::PolymarketClient;

let config = PolymarketConfig { ... };
let client = PolymarketClient::new(config).await?;

// Get market data
let markets = client.gamma.list_markets(100).await?;

// Place an order
let order = Order { ... };
let status = client.clob.place_order(&order).await?;
```

### `client/clob.rs`

#### `ClobClient`

Central Limit Order Book API client.

```rust
pub struct ClobClient { ... }

impl ClobClient {
    /// Create new CLOB client
    pub fn new(base_url: &str, signer: PolySigner, funder: Option<String>) -> Result<Self>;
    
    /// Get order book for a token
    pub async fn get_order_book(&self, token_id: &str) -> Result<OrderBook>;
    
    /// Place a new order
    pub async fn place_order(&self, order: &Order) -> Result<OrderStatus>;
    
    /// Cancel an order
    pub async fn cancel_order(&self, order_id: &str) -> Result<()>;
    
    /// Get order status
    pub async fn get_order(&self, order_id: &str) -> Result<OrderStatus>;
    
    /// Get all open orders
    pub async fn get_open_orders(&self) -> Result<Vec<OrderStatus>>;
    
    /// Get wallet balance
    pub async fn get_balance(&self) -> Result<Decimal>;
}
```

#### `OrderBook`

```rust
pub struct OrderBook {
    pub bids: Vec<OrderBookLevel>,
    pub asks: Vec<OrderBookLevel>,
}

pub struct OrderBookLevel {
    pub price: Decimal,
    pub size: Decimal,
}

impl OrderBook {
    /// Get best bid price
    pub fn best_bid(&self) -> Option<Decimal>;
    
    /// Get best ask price
    pub fn best_ask(&self) -> Option<Decimal>;
    
    /// Get spread
    pub fn spread(&self) -> Option<Decimal>;
}
```

### `client/gamma.rs`

#### `GammaClient`

Market data API client.

```rust
pub struct GammaClient { ... }

impl GammaClient {
    /// Create new Gamma client
    pub fn new(base_url: &str) -> Result<Self>;
    
    /// List active markets
    pub async fn list_markets(&self, limit: usize) -> Result<Vec<Market>>;
    
    /// Get specific market by ID
    pub async fn get_market(&self, market_id: &str) -> Result<Market>;
    
    /// Search markets by query
    pub async fn search_markets(&self, query: &str) -> Result<Vec<Market>>;
    
    /// Get market prices
    pub async fn get_prices(&self, token_ids: Vec<String>) -> Result<HashMap<String, Decimal>>;
}
```

### `client/websocket.rs`

#### `MarketStream`

Real-time market data stream.

```rust
pub struct MarketStream { ... }

impl MarketStream {
    /// Connect to WebSocket
    pub async fn connect(url: &str, token_ids: Vec<String>) -> Result<Self>;
    
    /// Receive next price update
    pub async fn next(&mut self) -> Option<PriceUpdate>;
    
    /// Close connection
    pub async fn close(&mut self);
}

pub struct PriceUpdate {
    pub token_id: String,
    pub price: Decimal,
    pub timestamp: DateTime<Utc>,
}
```

**Example:**
```rust
let mut stream = client.market_stream(vec!["token1".into()]).await?;

while let Some(update) = stream.next().await {
    println!("{}: {:.4}", update.token_id, update.price);
}
```

---

## Model Module

### `model/mod.rs`

#### `Prediction`

Result of probability estimation.

```rust
pub struct Prediction {
    pub probability: Decimal,  // 0.0 - 1.0
    pub confidence: Decimal,   // 0.0 - 1.0
    pub reasoning: String,     // Explanation
}
```

#### `ProbabilityModel` Trait

Interface for probability models.

```rust
#[async_trait]
pub trait ProbabilityModel: Send + Sync {
    /// Predict probability of "Yes" outcome
    async fn predict(&self, market: &Market) -> Result<Prediction>;
    
    /// Model name for logging
    fn name(&self) -> &str;
}
```

#### `EnsembleModel`

Combines multiple models with weighted averaging.

```rust
pub struct EnsembleModel { ... }

impl EnsembleModel {
    pub fn new() -> Self;
    
    /// Add a model with weight
    pub fn add_model(&mut self, model: Box<dyn ProbabilityModel>, weight: Decimal);
    
    /// Get weighted prediction
    pub async fn predict(&self, market: &Market) -> Result<Prediction>;
}
```

### `model/llm.rs`

#### `LlmModel`

LLM-based probability model.

```rust
pub struct LlmModel { ... }

pub enum LlmProvider {
    DeepSeek,
    Anthropic,
    OpenAI,
    Ollama,
    Compatible,  // OpenAI-compatible API
}

impl LlmModel {
    /// Create new LLM model
    pub fn new(provider: LlmProvider, api_key: &str, model: Option<&str>) -> Self;
    
    /// With custom base URL (for compatible providers)
    pub fn with_base_url(self, url: &str) -> Self;
}

#[async_trait]
impl ProbabilityModel for LlmModel {
    async fn predict(&self, market: &Market) -> Result<Prediction>;
    fn name(&self) -> &str;
}
```

**Example:**
```rust
use polymarket_bot::model::{LlmModel, LlmProvider, ProbabilityModel};

let model = LlmModel::new(
    LlmProvider::DeepSeek,
    "sk-xxx",
    Some("deepseek-chat")
);

let prediction = model.predict(&market).await?;
println!("Probability: {:.1}%", prediction.probability * 100);
println!("Confidence: {:.1}%", prediction.confidence * 100);
println!("Reasoning: {}", prediction.reasoning);
```

---

## Strategy Module

### `strategy/mod.rs`

#### `SignalGenerator`

Generates trading signals from predictions.

```rust
pub struct SignalGenerator { ... }

impl SignalGenerator {
    pub fn new(config: StrategyConfig, risk_config: RiskConfig) -> Self;
    
    /// Generate signal from market and prediction
    /// Returns None if edge/confidence below thresholds
    pub fn generate(&self, market: &Market, prediction: &Prediction) -> Option<Signal>;
}
```

**Example:**
```rust
use polymarket_bot::strategy::SignalGenerator;

let generator = SignalGenerator::new(strategy_config, risk_config);

if let Some(signal) = generator.generate(&market, &prediction) {
    println!("Signal: {:?} with {:.1}% edge", signal.side, signal.edge * 100);
}
```

### `strategy/compound.rs`

#### `CompoundStrategy`

Advanced strategy with dynamic sizing.

```rust
pub struct CompoundStrategy { ... }

impl CompoundStrategy {
    pub fn new(
        config: StrategyConfig,
        risk_config: RiskConfig,
        initial_balance: Decimal
    ) -> Self;
    
    /// Record trade result for dynamic adjustment
    pub fn record_result(&mut self, pnl: Decimal, edge: Decimal, confidence: Decimal);
    
    /// Update current balance
    pub fn update_balance(&mut self, current_balance: Decimal);
    
    /// Generate signal with compound-optimized sizing
    pub fn generate(
        &self,
        market: &Market,
        prediction: &Prediction,
        current_balance: Decimal
    ) -> Option<Signal>;
    
    /// Get current statistics
    pub fn get_stats(&self) -> CompoundStats;
}

pub struct CompoundStats {
    pub total_trades: usize,
    pub wins: usize,
    pub win_rate: f64,
    pub total_pnl: Decimal,
    pub current_kelly_mult: Decimal,  // 0.5 - 2.0
    pub win_streak: u32,
    pub lose_streak: u32,
    pub growth_from_initial: Decimal,
}
```

### `strategy/copy_trade.rs`

#### `CopyTrader`

Copy trading functionality.

```rust
pub struct CopyTrader { ... }

pub struct CopyTradeConfig {
    pub enabled: bool,
    pub follow_users: Vec<String>,
    pub follow_addresses: Vec<String>,
    pub copy_ratio: f64,      // 0.0 - 1.0
    pub delay_secs: u64,
}

pub struct CopySignal {
    pub trader: TopTrader,
    pub market_id: String,
    pub token_id: String,
    pub side: Side,
    pub size: Decimal,
    pub copy_size: Decimal,   // After ratio applied
}

impl CopyTrader {
    pub fn new(config: CopyTradeConfig) -> Self;
    
    /// Monitor and get copy signals
    pub async fn get_signals(&self) -> Result<Vec<CopySignal>>;
    
    /// Add trader to follow list
    pub fn follow(&mut self, user: &str);
    
    /// Remove trader from follow list
    pub fn unfollow(&mut self, user: &str);
}
```

### `strategy/crypto_hf.rs`

#### `CryptoHfStrategy`

Crypto high-frequency strategy (uses Binance data).

```rust
pub struct CryptoHfStrategy { ... }

pub struct CryptoPriceTracker { ... }

impl CryptoHfStrategy {
    pub fn new(symbols: Vec<String>) -> Self;
    
    /// Get current crypto signals
    pub async fn get_signals(&self) -> Result<Vec<Signal>>;
}

impl CryptoPriceTracker {
    /// Track price for symbol
    pub async fn get_price(&self, symbol: &str) -> Result<Decimal>;
    
    /// Get 15-minute price change
    pub async fn get_change_15m(&self, symbol: &str) -> Result<Decimal>;
}
```

---

## Executor Module

### `executor/mod.rs`

#### `Executor`

Base executor with risk management.

```rust
pub struct Executor { ... }

impl Executor {
    pub fn new(clob: ClobClient, risk_config: RiskConfig) -> Self;
    
    /// Execute a trading signal
    pub async fn execute(&self, signal: &Signal, portfolio_value: Decimal) -> Result<Option<Trade>>;
    
    /// Update daily P&L
    pub async fn update_pnl(&self, pnl_change: Decimal);
    
    /// Reset daily P&L (call at start of day)
    pub async fn reset_daily_pnl(&self);
    
    /// Get current positions
    pub async fn get_positions(&self) -> HashMap<String, Decimal>;
}
```

### `executor/smart_executor.rs`

#### `SmartExecutor`

Advanced executor with depth analysis and retry.

```rust
pub struct SmartExecutor { ... }

pub struct SmartExecutorConfig {
    pub max_retries: u32,       // Default: 3
    pub retry_delay_ms: u64,    // Default: 1000
    pub min_liquidity: Decimal, // Default: $50
    pub max_slippage: Decimal,  // Default: 2%
    pub batch_count: u32,       // Default: 3
    pub batch_delay_ms: u64,    // Default: 2000
    pub order_timeout_secs: u64,// Default: 30
}

pub struct DepthAnalysis {
    pub best_liquidity: Decimal,
    pub total_liquidity: Decimal,
    pub expected_price: Decimal,
    pub expected_slippage: Decimal,
    pub can_fill: bool,
}

pub struct ExecutionResult {
    pub filled_size: Decimal,
    pub average_price: Decimal,
    pub trades: Vec<Trade>,
    pub attempts: u32,
}

impl SmartExecutor {
    pub fn new(clob: ClobClient, config: SmartExecutorConfig) -> Self;
    
    /// Analyze orderbook depth
    pub fn analyze_depth(&self, book: &OrderBook, side: Side, size: Decimal) -> DepthAnalysis;
    
    /// Execute with automatic retry
    pub async fn execute_with_retry(
        &self,
        token_id: &str,
        side: Side,
        size: Decimal,
        market_id: &str,
    ) -> Result<ExecutionResult>;
    
    /// Execute in batches (for large orders)
    pub async fn execute_batched(
        &self,
        token_id: &str,
        side: Side,
        total_size: Decimal,
        market_id: &str,
    ) -> Result<ExecutionResult>;
    
    /// Check if order can be executed
    pub async fn can_execute(&self, token_id: &str, side: Side, size: Decimal) -> Result<bool>;
}
```

**Example:**
```rust
use polymarket_bot::executor::smart_executor::{SmartExecutor, SmartExecutorConfig};

let executor = SmartExecutor::new(clob, SmartExecutorConfig::default());

// Check liquidity first
let book = clob.get_order_book("token1").await?;
let analysis = executor.analyze_depth(&book, Side::Buy, dec!(100));

if analysis.can_fill {
    let result = executor.execute_with_retry("token1", Side::Buy, dec!(100), "market1").await?;
    println!("Filled {} @ {}", result.filled_size, result.average_price);
}
```

### `executor/gradual_exit.rs`

#### `GradualExit`

Gradual position unwinding.

```rust
pub struct GradualExit { ... }

pub struct GradualExitConfig {
    pub num_tranches: u32,      // Number of exit tranches
    pub interval_secs: u64,     // Time between tranches
    pub price_tolerance: Decimal, // Max price deviation
}

impl GradualExit {
    pub fn new(executor: SmartExecutor, config: GradualExitConfig) -> Self;
    
    /// Exit position gradually
    pub async fn exit(
        &self,
        token_id: &str,
        total_size: Decimal,
        market_id: &str,
    ) -> Result<Vec<ExecutionResult>>;
}
```

---

## Ingester Module

### `ingester/mod.rs`

#### `RawSignal`

Raw signal from external source.

```rust
pub struct RawSignal {
    pub source: String,         // "telegram", "twitter", "chain"
    pub source_id: String,      // Original message ID
    pub content: String,        // Raw content
    pub author: String,         // Author identifier
    pub author_trust: f64,      // 0.0 - 1.0
    pub timestamp: DateTime<Utc>,
    pub metadata: Option<Value>,
}
```

#### `ParsedSignal`

Processed signal after LLM extraction.

```rust
pub struct ParsedSignal {
    pub token: String,          // BTC, ETH, etc.
    pub direction: SignalDirection,
    pub timeframe: String,      // 5m, 1h, 1d
    pub confidence: f64,
    pub reasoning: String,
    pub action_type: ActionType,
    pub sources: Vec<RawSignal>,
    pub agg_score: f64,         // Aggregated score
    pub timestamp: DateTime<Utc>,
}

pub enum SignalDirection {
    Bullish,
    Bearish,
    Neutral,
}

pub enum ActionType {
    Entry,
    Exit,
    Warning,
    Info,
}
```

#### `SignalSource` Trait

```rust
#[async_trait]
pub trait SignalSource: Send + Sync {
    fn name(&self) -> &str;
    async fn run(&self, tx: mpsc::Sender<RawSignal>) -> Result<()>;
}
```

### `ingester/processor.rs`

#### `SignalProcessor`

LLM-based signal extraction.

```rust
pub struct SignalProcessor { ... }

impl SignalProcessor {
    pub fn new(llm: LlmModel, config: ProcessingConfig) -> Self;
    
    /// Process raw signal to parsed signal
    pub async fn process(&self, raw: RawSignal) -> Result<Option<ParsedSignal>>;
    
    /// Aggregate multiple signals
    pub fn aggregate(&self, signals: Vec<ParsedSignal>) -> Option<ParsedSignal>;
}
```

---

## Storage Module

### `storage/mod.rs`

#### `Database`

SQLite persistence layer.

```rust
pub struct Database { ... }

impl Database {
    /// Connect to database (creates if not exists)
    pub async fn connect<P: AsRef<Path>>(path: P) -> Result<Self>;
    
    /// Save a trade
    pub async fn save_trade(&self, trade: &Trade) -> Result<()>;
    
    /// Get recent trades
    pub async fn get_recent_trades(&self, limit: i64) -> Result<Vec<Trade>>;
    
    /// Get daily performance stats
    pub async fn get_daily_stats(&self) -> Result<PerformanceStats>;
}
```

**Example:**
```rust
use polymarket_bot::storage::Database;

let db = Database::connect("data/polymarket.db").await?;

// Save trade
db.save_trade(&trade).await?;

// Get recent trades
let trades = db.get_recent_trades(10).await?;
for trade in trades {
    println!("{}: {} @ {}", trade.side, trade.size, trade.price);
}
```

---

## Notify Module

### `notify/mod.rs`

#### `Notifier`

Telegram notification system.

```rust
pub struct Notifier { ... }

impl Notifier {
    pub fn new(bot_token: String, chat_id: String) -> Self;
    
    /// Create disabled notifier
    pub fn disabled() -> Self;
    
    /// Send raw message (HTML format)
    pub async fn send(&self, text: &str) -> Result<()>;
    
    /// Notify about signal found
    pub async fn signal_found(&self, signal: &Signal, market_question: &str) -> Result<()>;
    
    /// Notify about trade execution
    pub async fn trade_executed(&self, trade: &Trade, market_question: &str) -> Result<()>;
    
    /// Notify about error
    pub async fn error(&self, context: &str, error: &str) -> Result<()>;
    
    /// Send daily performance report
    pub async fn daily_report(&self, stats: &PerformanceStats, balance: Decimal) -> Result<()>;
    
    /// Notify bot startup
    pub async fn startup(&self, dry_run: bool) -> Result<()>;
    
    /// Notify bot shutdown
    pub async fn shutdown(&self, reason: &str) -> Result<()>;
    
    /// Risk alert notification
    pub async fn risk_alert(&self, alert_type: &str, message: &str) -> Result<()>;
}
```

**Example:**
```rust
use polymarket_bot::notify::Notifier;

let notifier = Notifier::new(bot_token, chat_id);

// Startup notification
notifier.startup(false).await?;

// Signal notification
notifier.signal_found(&signal, "Will BTC hit $150k?").await?;

// Custom message
notifier.send("<b>Custom Alert</b>\nSomething happened!").await?;
```

---

## Monitor Module

### `monitor/mod.rs`

#### `Monitor`

Performance tracking.

```rust
pub struct Monitor { ... }

pub struct TradeRecord {
    pub timestamp: DateTime<Utc>,
    pub market_id: String,
    pub side: String,
    pub size: Decimal,
    pub price: Decimal,
    pub pnl: Option<Decimal>,
}

pub struct PerformanceStats {
    pub total_trades: usize,
    pub winning_trades: usize,
    pub losing_trades: usize,
    pub win_rate: Decimal,
    pub total_pnl: Decimal,
    pub avg_pnl_per_trade: Decimal,
    pub sharpe_ratio: Option<Decimal>,
}

impl Monitor {
    pub fn new(max_history: usize) -> Self;
    
    /// Record a trade
    pub async fn record_trade(&self, record: TradeRecord);
    
    /// Get performance statistics
    pub async fn get_stats(&self) -> PerformanceStats;
    
    /// Log stats to console
    pub async fn log_stats(&self);
}
```

---

## Configuration Module

### `config.rs`

#### `Config`

Main configuration struct.

```rust
pub struct Config {
    pub polymarket: PolymarketConfig,
    pub strategy: StrategyConfig,
    pub risk: RiskConfig,
    pub database: DatabaseConfig,
    pub llm: Option<LlmConfig>,
    pub telegram: Option<TelegramConfig>,
    pub ingester: Option<IngesterConfig>,
    pub copy_trade: Option<CopyTradeConfig>,
}

impl Config {
    /// Load from file
    pub fn load<P: AsRef<Path>>(path: P) -> Result<Self>;
    
    /// Load from default locations
    pub fn load_default() -> Result<Self>;
}
```

See [MANUAL.md](MANUAL.md) for detailed configuration options.

---

## Error Handling

### `error.rs`

```rust
pub type Result<T> = std::result::Result<T, BotError>;

#[derive(Debug, thiserror::Error)]
pub enum BotError {
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("API error: {0}")]
    Api(String),
    
    #[error("Execution error: {0}")]
    Execution(String),
    
    #[error("Risk limit: {0}")]
    RiskLimit(String),
    
    #[error("LLM error: {0}")]
    Llm(String),
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
}
```

---

## Full Example

```rust
use polymarket_bot::{
    client::PolymarketClient,
    config::Config,
    executor::Executor,
    model::{LlmModel, LlmProvider, ProbabilityModel},
    notify::Notifier,
    storage::Database,
    strategy::SignalGenerator,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load configuration
    let config = Config::load("config.toml")?;
    
    // Initialize components
    let client = PolymarketClient::new(config.polymarket.clone()).await?;
    let db = Database::connect(&config.database.path).await?;
    let notifier = Notifier::new(
        config.telegram.as_ref().unwrap().bot_token.clone(),
        config.telegram.as_ref().unwrap().chat_id.clone(),
    );
    
    // Create LLM model
    let llm = LlmModel::new(
        LlmProvider::DeepSeek,
        &config.llm.as_ref().unwrap().api_key,
        config.llm.as_ref().and_then(|c| c.model.as_deref()),
    );
    
    // Create strategy and executor
    let generator = SignalGenerator::new(config.strategy.clone(), config.risk.clone());
    let executor = Executor::new(client.clob.clone(), config.risk.clone());
    
    // Notify startup
    notifier.startup(false).await?;
    
    // Main loop
    loop {
        // Get markets
        let markets = client.gamma.list_markets(50).await?;
        
        for market in markets {
            // Get prediction
            let prediction = llm.predict(&market).await?;
            
            // Generate signal
            if let Some(signal) = generator.generate(&market, &prediction) {
                // Notify
                notifier.signal_found(&signal, &market.question).await?;
                
                // Execute
                let balance = client.clob.get_balance().await?;
                if let Some(trade) = executor.execute(&signal, balance).await? {
                    db.save_trade(&trade).await?;
                    notifier.trade_executed(&trade, &market.question).await?;
                }
            }
        }
        
        tokio::time::sleep(std::time::Duration::from_secs(180)).await;
    }
}
```

---

*Generated: 2026-01-29*
